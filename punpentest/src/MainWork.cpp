#include "MainWork.hpp"

namespace ChOiler
{
  /**
   * @brief instanzieren und initialisieren der statischen Variablen
   *
   */
  const char *MainWorker::tag{"MainWorker"};           //! tag f端rs debug logging
  esp_timer_handle_t MainWorker::timerHandle{nullptr}; //! timer handle
  uint8_t volatile MainWorker::pumpCycles{8};

  /**
   * @brief initialisiere das Programm
   *
   */
  void MainWorker::init()
  {
    printf("controller ist starting...\n\n");
    //
    // initialisiere die Hardware
    //
    // gpio_install_isr_service(0); // gloabal einmalig f端r GPIO

    ESP_LOGI(tag, "init pump hardware...");
    //
    // Ausgabesignale Digital
    //
    gpio_config_t config_out = {.pin_bit_mask = BIT64(OUTPUT_PUMP_CONTROL) | BIT64(OUTPUT_LED),
                                .mode = GPIO_MODE_OUTPUT,
                                .pull_up_en = GPIO_PULLUP_DISABLE,
                                .pull_down_en = GPIO_PULLDOWN_DISABLE,
                                .intr_type = GPIO_INTR_DISABLE};
    gpio_config(&config_out);
    // Pumpe auf AUS ==> invertiertes Signal
    gpio_set_level(OUTPUT_PUMP_CONTROL, P_OFF);
    //
    // Hartware Timer f端r 20ms
    //
    ESP_LOGD(tag, "init pump hardware...OK");

    //
    // timer f端r Punpe starten
    //
    ESP_LOGD(tag, "init pump timer...");
    const esp_timer_create_args_t appTimerArgs =
        {
            .callback = &MainWorker::timerCallback,
            .arg = nullptr,
            .dispatch_method = ESP_TIMER_TASK,
            .name = "led_timer",
            .skip_unhandled_events = true};
    //
    // timer erzeugen
    //
    ESP_ERROR_CHECK(esp_timer_create(&appTimerArgs, &MainWorker::timerHandle));

    ESP_LOGD(tag, "init done.");
  }

  /**
   * @brief Hauptschleife des Programmes
   *
   */
  void MainWorker::run()
  {
    ESP_LOGI(tag, "%s: run start...", __func__);
    //
    // timer starten, microsekunden ( 20 ms soll es)
    //
    ESP_ERROR_CHECK(esp_timer_start_periodic(MainWorker::timerHandle, 20000));
    //
    uint64_t nowTime = esp_timer_get_time() + 5000 * 1000;
    gpio_set_level(OUTPUT_LED, 0);
    gpio_set_level(OUTPUT_PUMP_CONTROL, P_OFF);
    while (true)
    {
      if (esp_timer_get_time() > nowTime)
      {
        ESP_LOGI(tag, "%s: run <%03d> cycles...", __func__, MainWorker::pumpCycles);
        nowTime = esp_timer_get_time() + 7000 * 1000;
        MainWorker::pumpCycles += 8;
      }
      taskYIELD();
      vTaskDelay(pDelay);
      /*
      gpio_set_level(OUTPUT_LED, 1);
      gpio_set_level(OUTPUT_PUMP_CONTROL, 1);
      vTaskDelay(pDelay);
      gpio_set_level(OUTPUT_LED, 0);
      gpio_set_level(OUTPUT_PUMP_CONTROL, 0);
      vTaskDelay(yDelay);
      */
    }
  }

  void MainWorker::timerCallback(void *)
  {
    static volatile bool haveSwitchedOn = false;
    static volatile uint8_t off_phase{0};

    if (haveSwitchedOn)
    {
      haveSwitchedOn = false;
      // pumpen-pin Aus INVERTIERT WG SCHALTUNG
      gpio_set_level(OUTPUT_PUMP_CONTROL, P_OFF);
      gpio_set_level(OUTPUT_LED, 0);
      off_phase = 5;
    }
    else if ((MainWorker::pumpCycles > 0) && (off_phase < 1))
    {
      haveSwitchedOn = true;
      --MainWorker::pumpCycles;
      // pumpen-pin an INVERTIERT WG SCHALTUNG
      gpio_set_level(OUTPUT_PUMP_CONTROL, P_ON);
      gpio_set_level(OUTPUT_LED, 1);
    }
    else if (off_phase > 0)
    {
      --off_phase;
    }
  }

} // namespace ChOiler
